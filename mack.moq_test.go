// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mack_test

import (
	"context"
	"sync"

	"github.com/justenwalker/mack"
)

// Ensure, that HMACSchemeMock does implement mack.HMACScheme.
// If this is not the case, regenerate this file with moq.
var _ mack.HMACScheme = &HMACSchemeMock{}

// HMACSchemeMock is a mock implementation of mack.HMACScheme.
//
//	func TestSomethingThatUsesHMACScheme(t *testing.T) {
//
//		// make and configure a mocked mack.HMACScheme
//		mockedHMACScheme := &HMACSchemeMock{
//			HMACFunc: func(key []byte, out []byte, data []byte) error {
//				panic("mock out the HMAC method")
//			},
//			KeySizeFunc: func() int {
//				panic("mock out the KeySize method")
//			},
//		}
//
//		// use mockedHMACScheme in code that requires mack.HMACScheme
//		// and then make assertions.
//
//	}
type HMACSchemeMock struct {
	// HMACFunc mocks the HMAC method.
	HMACFunc func(key []byte, out []byte, data []byte) error

	// KeySizeFunc mocks the KeySize method.
	KeySizeFunc func() int

	// calls tracks calls to the methods.
	calls struct {
		// HMAC holds details about calls to the HMAC method.
		HMAC []struct {
			// Key is the key argument value.
			Key []byte
			// Out is the out argument value.
			Out []byte
			// Data is the data argument value.
			Data []byte
		}
		// KeySize holds details about calls to the KeySize method.
		KeySize []struct {
		}
	}
	lockHMAC    sync.RWMutex
	lockKeySize sync.RWMutex
}

// HMAC calls HMACFunc.
func (mock *HMACSchemeMock) HMAC(key []byte, out []byte, data []byte) error {
	if mock.HMACFunc == nil {
		panic("HMACSchemeMock.HMACFunc: method is nil but HMACScheme.HMAC was just called")
	}
	callInfo := struct {
		Key  []byte
		Out  []byte
		Data []byte
	}{
		Key:  key,
		Out:  out,
		Data: data,
	}
	mock.lockHMAC.Lock()
	mock.calls.HMAC = append(mock.calls.HMAC, callInfo)
	mock.lockHMAC.Unlock()
	return mock.HMACFunc(key, out, data)
}

// HMACCalls gets all the calls that were made to HMAC.
// Check the length with:
//
//	len(mockedHMACScheme.HMACCalls())
func (mock *HMACSchemeMock) HMACCalls() []struct {
	Key  []byte
	Out  []byte
	Data []byte
} {
	var calls []struct {
		Key  []byte
		Out  []byte
		Data []byte
	}
	mock.lockHMAC.RLock()
	calls = mock.calls.HMAC
	mock.lockHMAC.RUnlock()
	return calls
}

// KeySize calls KeySizeFunc.
func (mock *HMACSchemeMock) KeySize() int {
	if mock.KeySizeFunc == nil {
		panic("HMACSchemeMock.KeySizeFunc: method is nil but HMACScheme.KeySize was just called")
	}
	callInfo := struct {
	}{}
	mock.lockKeySize.Lock()
	mock.calls.KeySize = append(mock.calls.KeySize, callInfo)
	mock.lockKeySize.Unlock()
	return mock.KeySizeFunc()
}

// KeySizeCalls gets all the calls that were made to KeySize.
// Check the length with:
//
//	len(mockedHMACScheme.KeySizeCalls())
func (mock *HMACSchemeMock) KeySizeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockKeySize.RLock()
	calls = mock.calls.KeySize
	mock.lockKeySize.RUnlock()
	return calls
}

// Ensure, that EncryptionSchemeMock does implement mack.EncryptionScheme.
// If this is not the case, regenerate this file with moq.
var _ mack.EncryptionScheme = &EncryptionSchemeMock{}

// EncryptionSchemeMock is a mock implementation of mack.EncryptionScheme.
//
//	func TestSomethingThatUsesEncryptionScheme(t *testing.T) {
//
//		// make and configure a mocked mack.EncryptionScheme
//		mockedEncryptionScheme := &EncryptionSchemeMock{
//			DecryptFunc: func(out []byte, in []byte, key []byte) ([]byte, error) {
//				panic("mock out the Decrypt method")
//			},
//			EncryptFunc: func(out []byte, in []byte, key []byte) ([]byte, error) {
//				panic("mock out the Encrypt method")
//			},
//			KeySizeFunc: func() int {
//				panic("mock out the KeySize method")
//			},
//			OverheadFunc: func() int {
//				panic("mock out the Overhead method")
//			},
//		}
//
//		// use mockedEncryptionScheme in code that requires mack.EncryptionScheme
//		// and then make assertions.
//
//	}
type EncryptionSchemeMock struct {
	// DecryptFunc mocks the Decrypt method.
	DecryptFunc func(out []byte, in []byte, key []byte) ([]byte, error)

	// EncryptFunc mocks the Encrypt method.
	EncryptFunc func(out []byte, in []byte, key []byte) ([]byte, error)

	// KeySizeFunc mocks the KeySize method.
	KeySizeFunc func() int

	// OverheadFunc mocks the Overhead method.
	OverheadFunc func() int

	// calls tracks calls to the methods.
	calls struct {
		// Decrypt holds details about calls to the Decrypt method.
		Decrypt []struct {
			// Out is the out argument value.
			Out []byte
			// In is the in argument value.
			In []byte
			// Key is the key argument value.
			Key []byte
		}
		// Encrypt holds details about calls to the Encrypt method.
		Encrypt []struct {
			// Out is the out argument value.
			Out []byte
			// In is the in argument value.
			In []byte
			// Key is the key argument value.
			Key []byte
		}
		// KeySize holds details about calls to the KeySize method.
		KeySize []struct {
		}
		// Overhead holds details about calls to the Overhead method.
		Overhead []struct {
		}
	}
	lockDecrypt  sync.RWMutex
	lockEncrypt  sync.RWMutex
	lockKeySize  sync.RWMutex
	lockOverhead sync.RWMutex
}

// Decrypt calls DecryptFunc.
func (mock *EncryptionSchemeMock) Decrypt(out []byte, in []byte, key []byte) ([]byte, error) {
	if mock.DecryptFunc == nil {
		panic("EncryptionSchemeMock.DecryptFunc: method is nil but EncryptionScheme.Decrypt was just called")
	}
	callInfo := struct {
		Out []byte
		In  []byte
		Key []byte
	}{
		Out: out,
		In:  in,
		Key: key,
	}
	mock.lockDecrypt.Lock()
	mock.calls.Decrypt = append(mock.calls.Decrypt, callInfo)
	mock.lockDecrypt.Unlock()
	return mock.DecryptFunc(out, in, key)
}

// DecryptCalls gets all the calls that were made to Decrypt.
// Check the length with:
//
//	len(mockedEncryptionScheme.DecryptCalls())
func (mock *EncryptionSchemeMock) DecryptCalls() []struct {
	Out []byte
	In  []byte
	Key []byte
} {
	var calls []struct {
		Out []byte
		In  []byte
		Key []byte
	}
	mock.lockDecrypt.RLock()
	calls = mock.calls.Decrypt
	mock.lockDecrypt.RUnlock()
	return calls
}

// Encrypt calls EncryptFunc.
func (mock *EncryptionSchemeMock) Encrypt(out []byte, in []byte, key []byte) ([]byte, error) {
	if mock.EncryptFunc == nil {
		panic("EncryptionSchemeMock.EncryptFunc: method is nil but EncryptionScheme.Encrypt was just called")
	}
	callInfo := struct {
		Out []byte
		In  []byte
		Key []byte
	}{
		Out: out,
		In:  in,
		Key: key,
	}
	mock.lockEncrypt.Lock()
	mock.calls.Encrypt = append(mock.calls.Encrypt, callInfo)
	mock.lockEncrypt.Unlock()
	return mock.EncryptFunc(out, in, key)
}

// EncryptCalls gets all the calls that were made to Encrypt.
// Check the length with:
//
//	len(mockedEncryptionScheme.EncryptCalls())
func (mock *EncryptionSchemeMock) EncryptCalls() []struct {
	Out []byte
	In  []byte
	Key []byte
} {
	var calls []struct {
		Out []byte
		In  []byte
		Key []byte
	}
	mock.lockEncrypt.RLock()
	calls = mock.calls.Encrypt
	mock.lockEncrypt.RUnlock()
	return calls
}

// KeySize calls KeySizeFunc.
func (mock *EncryptionSchemeMock) KeySize() int {
	if mock.KeySizeFunc == nil {
		panic("EncryptionSchemeMock.KeySizeFunc: method is nil but EncryptionScheme.KeySize was just called")
	}
	callInfo := struct {
	}{}
	mock.lockKeySize.Lock()
	mock.calls.KeySize = append(mock.calls.KeySize, callInfo)
	mock.lockKeySize.Unlock()
	return mock.KeySizeFunc()
}

// KeySizeCalls gets all the calls that were made to KeySize.
// Check the length with:
//
//	len(mockedEncryptionScheme.KeySizeCalls())
func (mock *EncryptionSchemeMock) KeySizeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockKeySize.RLock()
	calls = mock.calls.KeySize
	mock.lockKeySize.RUnlock()
	return calls
}

// Overhead calls OverheadFunc.
func (mock *EncryptionSchemeMock) Overhead() int {
	if mock.OverheadFunc == nil {
		panic("EncryptionSchemeMock.OverheadFunc: method is nil but EncryptionScheme.Overhead was just called")
	}
	callInfo := struct {
	}{}
	mock.lockOverhead.Lock()
	mock.calls.Overhead = append(mock.calls.Overhead, callInfo)
	mock.lockOverhead.Unlock()
	return mock.OverheadFunc()
}

// OverheadCalls gets all the calls that were made to Overhead.
// Check the length with:
//
//	len(mockedEncryptionScheme.OverheadCalls())
func (mock *EncryptionSchemeMock) OverheadCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockOverhead.RLock()
	calls = mock.calls.Overhead
	mock.lockOverhead.RUnlock()
	return calls
}

// Ensure, that BindForRequestSchemeMock does implement mack.BindForRequestScheme.
// If this is not the case, regenerate this file with moq.
var _ mack.BindForRequestScheme = &BindForRequestSchemeMock{}

// BindForRequestSchemeMock is a mock implementation of mack.BindForRequestScheme.
//
//	func TestSomethingThatUsesBindForRequestScheme(t *testing.T) {
//
//		// make and configure a mocked mack.BindForRequestScheme
//		mockedBindForRequestScheme := &BindForRequestSchemeMock{
//			BindForRequestFunc: func(ts *mack.Macaroon, sig []byte) error {
//				panic("mock out the BindForRequest method")
//			},
//		}
//
//		// use mockedBindForRequestScheme in code that requires mack.BindForRequestScheme
//		// and then make assertions.
//
//	}
type BindForRequestSchemeMock struct {
	// BindForRequestFunc mocks the BindForRequest method.
	BindForRequestFunc func(ts *mack.Macaroon, sig []byte) error

	// calls tracks calls to the methods.
	calls struct {
		// BindForRequest holds details about calls to the BindForRequest method.
		BindForRequest []struct {
			// Ts is the ts argument value.
			Ts *mack.Macaroon
			// Sig is the sig argument value.
			Sig []byte
		}
	}
	lockBindForRequest sync.RWMutex
}

// BindForRequest calls BindForRequestFunc.
func (mock *BindForRequestSchemeMock) BindForRequest(ts *mack.Macaroon, sig []byte) error {
	if mock.BindForRequestFunc == nil {
		panic("BindForRequestSchemeMock.BindForRequestFunc: method is nil but BindForRequestScheme.BindForRequest was just called")
	}
	callInfo := struct {
		Ts  *mack.Macaroon
		Sig []byte
	}{
		Ts:  ts,
		Sig: sig,
	}
	mock.lockBindForRequest.Lock()
	mock.calls.BindForRequest = append(mock.calls.BindForRequest, callInfo)
	mock.lockBindForRequest.Unlock()
	return mock.BindForRequestFunc(ts, sig)
}

// BindForRequestCalls gets all the calls that were made to BindForRequest.
// Check the length with:
//
//	len(mockedBindForRequestScheme.BindForRequestCalls())
func (mock *BindForRequestSchemeMock) BindForRequestCalls() []struct {
	Ts  *mack.Macaroon
	Sig []byte
} {
	var calls []struct {
		Ts  *mack.Macaroon
		Sig []byte
	}
	mock.lockBindForRequest.RLock()
	calls = mock.calls.BindForRequest
	mock.lockBindForRequest.RUnlock()
	return calls
}

// Ensure, that PredicateCheckerMock does implement mack.PredicateChecker.
// If this is not the case, regenerate this file with moq.
var _ mack.PredicateChecker = &PredicateCheckerMock{}

// PredicateCheckerMock is a mock implementation of mack.PredicateChecker.
//
//	func TestSomethingThatUsesPredicateChecker(t *testing.T) {
//
//		// make and configure a mocked mack.PredicateChecker
//		mockedPredicateChecker := &PredicateCheckerMock{
//			CheckPredicateFunc: func(ctx context.Context, predicate []byte) (bool, error) {
//				panic("mock out the CheckPredicate method")
//			},
//		}
//
//		// use mockedPredicateChecker in code that requires mack.PredicateChecker
//		// and then make assertions.
//
//	}
type PredicateCheckerMock struct {
	// CheckPredicateFunc mocks the CheckPredicate method.
	CheckPredicateFunc func(ctx context.Context, predicate []byte) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// CheckPredicate holds details about calls to the CheckPredicate method.
		CheckPredicate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Predicate is the predicate argument value.
			Predicate []byte
		}
	}
	lockCheckPredicate sync.RWMutex
}

// CheckPredicate calls CheckPredicateFunc.
func (mock *PredicateCheckerMock) CheckPredicate(ctx context.Context, predicate []byte) (bool, error) {
	if mock.CheckPredicateFunc == nil {
		panic("PredicateCheckerMock.CheckPredicateFunc: method is nil but PredicateChecker.CheckPredicate was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Predicate []byte
	}{
		Ctx:       ctx,
		Predicate: predicate,
	}
	mock.lockCheckPredicate.Lock()
	mock.calls.CheckPredicate = append(mock.calls.CheckPredicate, callInfo)
	mock.lockCheckPredicate.Unlock()
	return mock.CheckPredicateFunc(ctx, predicate)
}

// CheckPredicateCalls gets all the calls that were made to CheckPredicate.
// Check the length with:
//
//	len(mockedPredicateChecker.CheckPredicateCalls())
func (mock *PredicateCheckerMock) CheckPredicateCalls() []struct {
	Ctx       context.Context
	Predicate []byte
} {
	var calls []struct {
		Ctx       context.Context
		Predicate []byte
	}
	mock.lockCheckPredicate.RLock()
	calls = mock.calls.CheckPredicate
	mock.lockCheckPredicate.RUnlock()
	return calls
}

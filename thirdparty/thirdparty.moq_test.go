// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package thirdparty_test

import (
	"context"
	"sync"

	macaroon "github.com/justenwalker/mack"
	"github.com/justenwalker/mack/thirdparty"
)

// Ensure, that ThirdPartyMock does implement thirdparty.ThirdParty.
// If this is not the case, regenerate this file with moq.
var _ thirdparty.ThirdParty = &ThirdPartyMock{}

// ThirdPartyMock is a mock implementation of thirdparty.ThirdParty.
//
//	func TestSomethingThatUsesThirdParty(t *testing.T) {
//
//		// make and configure a mocked thirdparty.ThirdParty
//		mockedThirdParty := &ThirdPartyMock{
//			DischargeCaveatFunc: func(ctx context.Context, c *macaroon.Caveat) (macaroon.Macaroon, error) {
//				panic("mock out the DischargeCaveat method")
//			},
//			MatchCaveatFunc: func(c *macaroon.Caveat) bool {
//				panic("mock out the MatchCaveat method")
//			},
//		}
//
//		// use mockedThirdParty in code that requires thirdparty.ThirdParty
//		// and then make assertions.
//
//	}
type ThirdPartyMock struct {
	// DischargeCaveatFunc mocks the DischargeCaveat method.
	DischargeCaveatFunc func(ctx context.Context, c *macaroon.Caveat) (macaroon.Macaroon, error)

	// MatchCaveatFunc mocks the MatchCaveat method.
	MatchCaveatFunc func(c *macaroon.Caveat) bool

	// calls tracks calls to the methods.
	calls struct {
		// DischargeCaveat holds details about calls to the DischargeCaveat method.
		DischargeCaveat []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// C is the c argument value.
			C *macaroon.Caveat
		}
		// MatchCaveat holds details about calls to the MatchCaveat method.
		MatchCaveat []struct {
			// C is the c argument value.
			C *macaroon.Caveat
		}
	}
	lockDischargeCaveat sync.RWMutex
	lockMatchCaveat     sync.RWMutex
}

// DischargeCaveat calls DischargeCaveatFunc.
func (mock *ThirdPartyMock) DischargeCaveat(ctx context.Context, c *macaroon.Caveat) (macaroon.Macaroon, error) {
	if mock.DischargeCaveatFunc == nil {
		panic("ThirdPartyMock.DischargeCaveatFunc: method is nil but ThirdParty.DischargeCaveat was just called")
	}
	callInfo := struct {
		Ctx context.Context
		C   *macaroon.Caveat
	}{
		Ctx: ctx,
		C:   c,
	}
	mock.lockDischargeCaveat.Lock()
	mock.calls.DischargeCaveat = append(mock.calls.DischargeCaveat, callInfo)
	mock.lockDischargeCaveat.Unlock()
	return mock.DischargeCaveatFunc(ctx, c)
}

// DischargeCaveatCalls gets all the calls that were made to DischargeCaveat.
// Check the length with:
//
//	len(mockedThirdParty.DischargeCaveatCalls())
func (mock *ThirdPartyMock) DischargeCaveatCalls() []struct {
	Ctx context.Context
	C   *macaroon.Caveat
} {
	var calls []struct {
		Ctx context.Context
		C   *macaroon.Caveat
	}
	mock.lockDischargeCaveat.RLock()
	calls = mock.calls.DischargeCaveat
	mock.lockDischargeCaveat.RUnlock()
	return calls
}

// MatchCaveat calls MatchCaveatFunc.
func (mock *ThirdPartyMock) MatchCaveat(c *macaroon.Caveat) bool {
	if mock.MatchCaveatFunc == nil {
		panic("ThirdPartyMock.MatchCaveatFunc: method is nil but ThirdParty.MatchCaveat was just called")
	}
	callInfo := struct {
		C *macaroon.Caveat
	}{
		C: c,
	}
	mock.lockMatchCaveat.Lock()
	mock.calls.MatchCaveat = append(mock.calls.MatchCaveat, callInfo)
	mock.lockMatchCaveat.Unlock()
	return mock.MatchCaveatFunc(c)
}

// MatchCaveatCalls gets all the calls that were made to MatchCaveat.
// Check the length with:
//
//	len(mockedThirdParty.MatchCaveatCalls())
func (mock *ThirdPartyMock) MatchCaveatCalls() []struct {
	C *macaroon.Caveat
} {
	var calls []struct {
		C *macaroon.Caveat
	}
	mock.lockMatchCaveat.RLock()
	calls = mock.calls.MatchCaveat
	mock.lockMatchCaveat.RUnlock()
	return calls
}

// Ensure, that TicketExtractorMock does implement thirdparty.TicketExtractor.
// If this is not the case, regenerate this file with moq.
var _ thirdparty.TicketExtractor = &TicketExtractorMock{}

// TicketExtractorMock is a mock implementation of thirdparty.TicketExtractor.
//
//	func TestSomethingThatUsesTicketExtractor(t *testing.T) {
//
//		// make and configure a mocked thirdparty.TicketExtractor
//		mockedTicketExtractor := &TicketExtractorMock{
//			ExtractTicketFunc: func(ctx context.Context, cID []byte) (*thirdparty.Ticket, error) {
//				panic("mock out the ExtractTicket method")
//			},
//		}
//
//		// use mockedTicketExtractor in code that requires thirdparty.TicketExtractor
//		// and then make assertions.
//
//	}
type TicketExtractorMock struct {
	// ExtractTicketFunc mocks the ExtractTicket method.
	ExtractTicketFunc func(ctx context.Context, cID []byte) (*thirdparty.Ticket, error)

	// calls tracks calls to the methods.
	calls struct {
		// ExtractTicket holds details about calls to the ExtractTicket method.
		ExtractTicket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CID is the cID argument value.
			CID []byte
		}
	}
	lockExtractTicket sync.RWMutex
}

// ExtractTicket calls ExtractTicketFunc.
func (mock *TicketExtractorMock) ExtractTicket(ctx context.Context, cID []byte) (*thirdparty.Ticket, error) {
	if mock.ExtractTicketFunc == nil {
		panic("TicketExtractorMock.ExtractTicketFunc: method is nil but TicketExtractor.ExtractTicket was just called")
	}
	callInfo := struct {
		Ctx context.Context
		CID []byte
	}{
		Ctx: ctx,
		CID: cID,
	}
	mock.lockExtractTicket.Lock()
	mock.calls.ExtractTicket = append(mock.calls.ExtractTicket, callInfo)
	mock.lockExtractTicket.Unlock()
	return mock.ExtractTicketFunc(ctx, cID)
}

// ExtractTicketCalls gets all the calls that were made to ExtractTicket.
// Check the length with:
//
//	len(mockedTicketExtractor.ExtractTicketCalls())
func (mock *TicketExtractorMock) ExtractTicketCalls() []struct {
	Ctx context.Context
	CID []byte
} {
	var calls []struct {
		Ctx context.Context
		CID []byte
	}
	mock.lockExtractTicket.RLock()
	calls = mock.calls.ExtractTicket
	mock.lockExtractTicket.RUnlock()
	return calls
}

// Ensure, that CaveatIDIssuerMock does implement thirdparty.CaveatIDIssuer.
// If this is not the case, regenerate this file with moq.
var _ thirdparty.CaveatIDIssuer = &CaveatIDIssuerMock{}

// CaveatIDIssuerMock is a mock implementation of thirdparty.CaveatIDIssuer.
//
//	func TestSomethingThatUsesCaveatIDIssuer(t *testing.T) {
//
//		// make and configure a mocked thirdparty.CaveatIDIssuer
//		mockedCaveatIDIssuer := &CaveatIDIssuerMock{
//			IssueCaveatIDFunc: func(ctx context.Context, ticket thirdparty.Ticket) ([]byte, error) {
//				panic("mock out the IssueCaveatID method")
//			},
//		}
//
//		// use mockedCaveatIDIssuer in code that requires thirdparty.CaveatIDIssuer
//		// and then make assertions.
//
//	}
type CaveatIDIssuerMock struct {
	// IssueCaveatIDFunc mocks the IssueCaveatID method.
	IssueCaveatIDFunc func(ctx context.Context, ticket thirdparty.Ticket) ([]byte, error)

	// calls tracks calls to the methods.
	calls struct {
		// IssueCaveatID holds details about calls to the IssueCaveatID method.
		IssueCaveatID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ticket is the ticket argument value.
			Ticket thirdparty.Ticket
		}
	}
	lockIssueCaveatID sync.RWMutex
}

// IssueCaveatID calls IssueCaveatIDFunc.
func (mock *CaveatIDIssuerMock) IssueCaveatID(ctx context.Context, ticket thirdparty.Ticket) ([]byte, error) {
	if mock.IssueCaveatIDFunc == nil {
		panic("CaveatIDIssuerMock.IssueCaveatIDFunc: method is nil but CaveatIDIssuer.IssueCaveatID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Ticket thirdparty.Ticket
	}{
		Ctx:    ctx,
		Ticket: ticket,
	}
	mock.lockIssueCaveatID.Lock()
	mock.calls.IssueCaveatID = append(mock.calls.IssueCaveatID, callInfo)
	mock.lockIssueCaveatID.Unlock()
	return mock.IssueCaveatIDFunc(ctx, ticket)
}

// IssueCaveatIDCalls gets all the calls that were made to IssueCaveatID.
// Check the length with:
//
//	len(mockedCaveatIDIssuer.IssueCaveatIDCalls())
func (mock *CaveatIDIssuerMock) IssueCaveatIDCalls() []struct {
	Ctx    context.Context
	Ticket thirdparty.Ticket
} {
	var calls []struct {
		Ctx    context.Context
		Ticket thirdparty.Ticket
	}
	mock.lockIssueCaveatID.RLock()
	calls = mock.calls.IssueCaveatID
	mock.lockIssueCaveatID.RUnlock()
	return calls
}

// Ensure, that PredicateCheckerMock does implement thirdparty.PredicateChecker.
// If this is not the case, regenerate this file with moq.
var _ thirdparty.PredicateChecker = &PredicateCheckerMock{}

// PredicateCheckerMock is a mock implementation of thirdparty.PredicateChecker.
//
//	func TestSomethingThatUsesPredicateChecker(t *testing.T) {
//
//		// make and configure a mocked thirdparty.PredicateChecker
//		mockedPredicateChecker := &PredicateCheckerMock{
//			CheckPredicateFunc: func(ctx context.Context, predicate []byte) (bool, error) {
//				panic("mock out the CheckPredicate method")
//			},
//		}
//
//		// use mockedPredicateChecker in code that requires thirdparty.PredicateChecker
//		// and then make assertions.
//
//	}
type PredicateCheckerMock struct {
	// CheckPredicateFunc mocks the CheckPredicate method.
	CheckPredicateFunc func(ctx context.Context, predicate []byte) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// CheckPredicate holds details about calls to the CheckPredicate method.
		CheckPredicate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Predicate is the predicate argument value.
			Predicate []byte
		}
	}
	lockCheckPredicate sync.RWMutex
}

// CheckPredicate calls CheckPredicateFunc.
func (mock *PredicateCheckerMock) CheckPredicate(ctx context.Context, predicate []byte) (bool, error) {
	if mock.CheckPredicateFunc == nil {
		panic("PredicateCheckerMock.CheckPredicateFunc: method is nil but PredicateChecker.CheckPredicate was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Predicate []byte
	}{
		Ctx:       ctx,
		Predicate: predicate,
	}
	mock.lockCheckPredicate.Lock()
	mock.calls.CheckPredicate = append(mock.calls.CheckPredicate, callInfo)
	mock.lockCheckPredicate.Unlock()
	return mock.CheckPredicateFunc(ctx, predicate)
}

// CheckPredicateCalls gets all the calls that were made to CheckPredicate.
// Check the length with:
//
//	len(mockedPredicateChecker.CheckPredicateCalls())
func (mock *PredicateCheckerMock) CheckPredicateCalls() []struct {
	Ctx       context.Context
	Predicate []byte
} {
	var calls []struct {
		Ctx       context.Context
		Predicate []byte
	}
	mock.lockCheckPredicate.RLock()
	calls = mock.calls.CheckPredicate
	mock.lockCheckPredicate.RUnlock()
	return calls
}

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package exchange_test

import (
	"sync"

	"github.com/justenwalker/mack/thirdparty"
	"github.com/justenwalker/mack/thirdparty/exchange"
)

// Ensure, that EncoderMock does implement exchange.Encoder.
// If this is not the case, regenerate this file with moq.
var _ exchange.Encoder = &EncoderMock{}

// EncoderMock is a mock implementation of exchange.Encoder.
//
//	func TestSomethingThatUsesEncoder(t *testing.T) {
//
//		// make and configure a mocked exchange.Encoder
//		mockedEncoder := &EncoderMock{
//			EncodeMessageFunc: func(em *exchange.EncryptedMessage) ([]byte, error) {
//				panic("mock out the EncodeMessage method")
//			},
//			EncodeTicketFunc: func(t thirdparty.Ticket) ([]byte, error) {
//				panic("mock out the EncodeTicket method")
//			},
//		}
//
//		// use mockedEncoder in code that requires exchange.Encoder
//		// and then make assertions.
//
//	}
type EncoderMock struct {
	// EncodeMessageFunc mocks the EncodeMessage method.
	EncodeMessageFunc func(em *exchange.EncryptedMessage) ([]byte, error)

	// EncodeTicketFunc mocks the EncodeTicket method.
	EncodeTicketFunc func(t thirdparty.Ticket) ([]byte, error)

	// calls tracks calls to the methods.
	calls struct {
		// EncodeMessage holds details about calls to the EncodeMessage method.
		EncodeMessage []struct {
			// Em is the em argument value.
			Em *exchange.EncryptedMessage
		}
		// EncodeTicket holds details about calls to the EncodeTicket method.
		EncodeTicket []struct {
			// T is the t argument value.
			T thirdparty.Ticket
		}
	}
	lockEncodeMessage sync.RWMutex
	lockEncodeTicket  sync.RWMutex
}

// EncodeMessage calls EncodeMessageFunc.
func (mock *EncoderMock) EncodeMessage(em *exchange.EncryptedMessage) ([]byte, error) {
	if mock.EncodeMessageFunc == nil {
		panic("EncoderMock.EncodeMessageFunc: method is nil but Encoder.EncodeMessage was just called")
	}
	callInfo := struct {
		Em *exchange.EncryptedMessage
	}{
		Em: em,
	}
	mock.lockEncodeMessage.Lock()
	mock.calls.EncodeMessage = append(mock.calls.EncodeMessage, callInfo)
	mock.lockEncodeMessage.Unlock()
	return mock.EncodeMessageFunc(em)
}

// EncodeMessageCalls gets all the calls that were made to EncodeMessage.
// Check the length with:
//
//	len(mockedEncoder.EncodeMessageCalls())
func (mock *EncoderMock) EncodeMessageCalls() []struct {
	Em *exchange.EncryptedMessage
} {
	var calls []struct {
		Em *exchange.EncryptedMessage
	}
	mock.lockEncodeMessage.RLock()
	calls = mock.calls.EncodeMessage
	mock.lockEncodeMessage.RUnlock()
	return calls
}

// EncodeTicket calls EncodeTicketFunc.
func (mock *EncoderMock) EncodeTicket(t thirdparty.Ticket) ([]byte, error) {
	if mock.EncodeTicketFunc == nil {
		panic("EncoderMock.EncodeTicketFunc: method is nil but Encoder.EncodeTicket was just called")
	}
	callInfo := struct {
		T thirdparty.Ticket
	}{
		T: t,
	}
	mock.lockEncodeTicket.Lock()
	mock.calls.EncodeTicket = append(mock.calls.EncodeTicket, callInfo)
	mock.lockEncodeTicket.Unlock()
	return mock.EncodeTicketFunc(t)
}

// EncodeTicketCalls gets all the calls that were made to EncodeTicket.
// Check the length with:
//
//	len(mockedEncoder.EncodeTicketCalls())
func (mock *EncoderMock) EncodeTicketCalls() []struct {
	T thirdparty.Ticket
} {
	var calls []struct {
		T thirdparty.Ticket
	}
	mock.lockEncodeTicket.RLock()
	calls = mock.calls.EncodeTicket
	mock.lockEncodeTicket.RUnlock()
	return calls
}

// Ensure, that EncryptorMock does implement exchange.Encryptor.
// If this is not the case, regenerate this file with moq.
var _ exchange.Encryptor = &EncryptorMock{}

// EncryptorMock is a mock implementation of exchange.Encryptor.
//
//	func TestSomethingThatUsesEncryptor(t *testing.T) {
//
//		// make and configure a mocked exchange.Encryptor
//		mockedEncryptor := &EncryptorMock{
//			EncryptMessageFunc: func(msg []byte) (*exchange.EncryptedMessage, error) {
//				panic("mock out the EncryptMessage method")
//			},
//		}
//
//		// use mockedEncryptor in code that requires exchange.Encryptor
//		// and then make assertions.
//
//	}
type EncryptorMock struct {
	// EncryptMessageFunc mocks the EncryptMessage method.
	EncryptMessageFunc func(msg []byte) (*exchange.EncryptedMessage, error)

	// calls tracks calls to the methods.
	calls struct {
		// EncryptMessage holds details about calls to the EncryptMessage method.
		EncryptMessage []struct {
			// Msg is the msg argument value.
			Msg []byte
		}
	}
	lockEncryptMessage sync.RWMutex
}

// EncryptMessage calls EncryptMessageFunc.
func (mock *EncryptorMock) EncryptMessage(msg []byte) (*exchange.EncryptedMessage, error) {
	if mock.EncryptMessageFunc == nil {
		panic("EncryptorMock.EncryptMessageFunc: method is nil but Encryptor.EncryptMessage was just called")
	}
	callInfo := struct {
		Msg []byte
	}{
		Msg: msg,
	}
	mock.lockEncryptMessage.Lock()
	mock.calls.EncryptMessage = append(mock.calls.EncryptMessage, callInfo)
	mock.lockEncryptMessage.Unlock()
	return mock.EncryptMessageFunc(msg)
}

// EncryptMessageCalls gets all the calls that were made to EncryptMessage.
// Check the length with:
//
//	len(mockedEncryptor.EncryptMessageCalls())
func (mock *EncryptorMock) EncryptMessageCalls() []struct {
	Msg []byte
} {
	var calls []struct {
		Msg []byte
	}
	mock.lockEncryptMessage.RLock()
	calls = mock.calls.EncryptMessage
	mock.lockEncryptMessage.RUnlock()
	return calls
}

// Ensure, that DecoderMock does implement exchange.Decoder.
// If this is not the case, regenerate this file with moq.
var _ exchange.Decoder = &DecoderMock{}

// DecoderMock is a mock implementation of exchange.Decoder.
//
//	func TestSomethingThatUsesDecoder(t *testing.T) {
//
//		// make and configure a mocked exchange.Decoder
//		mockedDecoder := &DecoderMock{
//			DecodeMessageFunc: func(msg []byte) (*exchange.EncryptedMessage, error) {
//				panic("mock out the DecodeMessage method")
//			},
//			DecodeTicketFunc: func(bs []byte) (*thirdparty.Ticket, error) {
//				panic("mock out the DecodeTicket method")
//			},
//		}
//
//		// use mockedDecoder in code that requires exchange.Decoder
//		// and then make assertions.
//
//	}
type DecoderMock struct {
	// DecodeMessageFunc mocks the DecodeMessage method.
	DecodeMessageFunc func(msg []byte) (*exchange.EncryptedMessage, error)

	// DecodeTicketFunc mocks the DecodeTicket method.
	DecodeTicketFunc func(bs []byte) (*thirdparty.Ticket, error)

	// calls tracks calls to the methods.
	calls struct {
		// DecodeMessage holds details about calls to the DecodeMessage method.
		DecodeMessage []struct {
			// Msg is the msg argument value.
			Msg []byte
		}
		// DecodeTicket holds details about calls to the DecodeTicket method.
		DecodeTicket []struct {
			// Bs is the bs argument value.
			Bs []byte
		}
	}
	lockDecodeMessage sync.RWMutex
	lockDecodeTicket  sync.RWMutex
}

// DecodeMessage calls DecodeMessageFunc.
func (mock *DecoderMock) DecodeMessage(msg []byte) (*exchange.EncryptedMessage, error) {
	if mock.DecodeMessageFunc == nil {
		panic("DecoderMock.DecodeMessageFunc: method is nil but Decoder.DecodeMessage was just called")
	}
	callInfo := struct {
		Msg []byte
	}{
		Msg: msg,
	}
	mock.lockDecodeMessage.Lock()
	mock.calls.DecodeMessage = append(mock.calls.DecodeMessage, callInfo)
	mock.lockDecodeMessage.Unlock()
	return mock.DecodeMessageFunc(msg)
}

// DecodeMessageCalls gets all the calls that were made to DecodeMessage.
// Check the length with:
//
//	len(mockedDecoder.DecodeMessageCalls())
func (mock *DecoderMock) DecodeMessageCalls() []struct {
	Msg []byte
} {
	var calls []struct {
		Msg []byte
	}
	mock.lockDecodeMessage.RLock()
	calls = mock.calls.DecodeMessage
	mock.lockDecodeMessage.RUnlock()
	return calls
}

// DecodeTicket calls DecodeTicketFunc.
func (mock *DecoderMock) DecodeTicket(bs []byte) (*thirdparty.Ticket, error) {
	if mock.DecodeTicketFunc == nil {
		panic("DecoderMock.DecodeTicketFunc: method is nil but Decoder.DecodeTicket was just called")
	}
	callInfo := struct {
		Bs []byte
	}{
		Bs: bs,
	}
	mock.lockDecodeTicket.Lock()
	mock.calls.DecodeTicket = append(mock.calls.DecodeTicket, callInfo)
	mock.lockDecodeTicket.Unlock()
	return mock.DecodeTicketFunc(bs)
}

// DecodeTicketCalls gets all the calls that were made to DecodeTicket.
// Check the length with:
//
//	len(mockedDecoder.DecodeTicketCalls())
func (mock *DecoderMock) DecodeTicketCalls() []struct {
	Bs []byte
} {
	var calls []struct {
		Bs []byte
	}
	mock.lockDecodeTicket.RLock()
	calls = mock.calls.DecodeTicket
	mock.lockDecodeTicket.RUnlock()
	return calls
}

// Ensure, that DecryptorMock does implement exchange.Decryptor.
// If this is not the case, regenerate this file with moq.
var _ exchange.Decryptor = &DecryptorMock{}

// DecryptorMock is a mock implementation of exchange.Decryptor.
//
//	func TestSomethingThatUsesDecryptor(t *testing.T) {
//
//		// make and configure a mocked exchange.Decryptor
//		mockedDecryptor := &DecryptorMock{
//			DecryptMessageFunc: func(em *exchange.EncryptedMessage) ([]byte, error) {
//				panic("mock out the DecryptMessage method")
//			},
//		}
//
//		// use mockedDecryptor in code that requires exchange.Decryptor
//		// and then make assertions.
//
//	}
type DecryptorMock struct {
	// DecryptMessageFunc mocks the DecryptMessage method.
	DecryptMessageFunc func(em *exchange.EncryptedMessage) ([]byte, error)

	// calls tracks calls to the methods.
	calls struct {
		// DecryptMessage holds details about calls to the DecryptMessage method.
		DecryptMessage []struct {
			// Em is the em argument value.
			Em *exchange.EncryptedMessage
		}
	}
	lockDecryptMessage sync.RWMutex
}

// DecryptMessage calls DecryptMessageFunc.
func (mock *DecryptorMock) DecryptMessage(em *exchange.EncryptedMessage) ([]byte, error) {
	if mock.DecryptMessageFunc == nil {
		panic("DecryptorMock.DecryptMessageFunc: method is nil but Decryptor.DecryptMessage was just called")
	}
	callInfo := struct {
		Em *exchange.EncryptedMessage
	}{
		Em: em,
	}
	mock.lockDecryptMessage.Lock()
	mock.calls.DecryptMessage = append(mock.calls.DecryptMessage, callInfo)
	mock.lockDecryptMessage.Unlock()
	return mock.DecryptMessageFunc(em)
}

// DecryptMessageCalls gets all the calls that were made to DecryptMessage.
// Check the length with:
//
//	len(mockedDecryptor.DecryptMessageCalls())
func (mock *DecryptorMock) DecryptMessageCalls() []struct {
	Em *exchange.EncryptedMessage
} {
	var calls []struct {
		Em *exchange.EncryptedMessage
	}
	mock.lockDecryptMessage.RLock()
	calls = mock.calls.DecryptMessage
	mock.lockDecryptMessage.RUnlock()
	return calls
}
